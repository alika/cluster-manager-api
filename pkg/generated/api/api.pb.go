// Code generated by protoc-gen-go. DO NOT EDIT.
// source: api.proto

/*
Package cluster_manager_api is a generated protocol buffer package.

It is generated from these files:
	api.proto

It has these top-level messages:
	HelloWorldMsg
	HelloWorldReply
	GetPodCountMsg
	GetPodCountReply
	CreateClusterMsg
	CreateClusterReply
	GetClusterMsg
	GetClusterReply
	DeleteClusterMsg
	DeleteClusterReply
	GetClusterListMsg
	GetClusterListReply
	ClusterItem
	ClusterDetailItem
	Error
	ProvisionTillerMsg
	ProvisionTillerReply
	InstallHelmChartMsg
	InstallHelmChartReply
	DeleteHelmChartMsg
	DeleteHelmChartReply
	GenericTillerSetting
	GenericHelmChart
	CreateClusterProviderSpec
	CreateClusterMaaSSpec
	CreateClusterAWSSpec
	GetVersionMsg
	GetVersionReply
*/
package cluster_manager_api

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger/options"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// The Hello World request
type HelloWorldMsg struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *HelloWorldMsg) Reset()                    { *m = HelloWorldMsg{} }
func (m *HelloWorldMsg) String() string            { return proto.CompactTextString(m) }
func (*HelloWorldMsg) ProtoMessage()               {}
func (*HelloWorldMsg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *HelloWorldMsg) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// The response to Hello World
type HelloWorldReply struct {
	Message string `protobuf:"bytes,1,opt,name=message" json:"message,omitempty"`
}

func (m *HelloWorldReply) Reset()                    { *m = HelloWorldReply{} }
func (m *HelloWorldReply) String() string            { return proto.CompactTextString(m) }
func (*HelloWorldReply) ProtoMessage()               {}
func (*HelloWorldReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *HelloWorldReply) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type GetPodCountMsg struct {
	// Namespace to fetch the pod count
	// Leave empty to query all namespaces
	Namespace string `protobuf:"bytes,1,opt,name=namespace" json:"namespace,omitempty"`
}

func (m *GetPodCountMsg) Reset()                    { *m = GetPodCountMsg{} }
func (m *GetPodCountMsg) String() string            { return proto.CompactTextString(m) }
func (*GetPodCountMsg) ProtoMessage()               {}
func (*GetPodCountMsg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *GetPodCountMsg) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

type GetPodCountReply struct {
	// Number of pods in the namespace (or all namespaces)
	Pods int32 `protobuf:"varint,1,opt,name=pods" json:"pods,omitempty"`
}

func (m *GetPodCountReply) Reset()                    { *m = GetPodCountReply{} }
func (m *GetPodCountReply) String() string            { return proto.CompactTextString(m) }
func (*GetPodCountReply) ProtoMessage()               {}
func (*GetPodCountReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *GetPodCountReply) GetPods() int32 {
	if m != nil {
		return m.Pods
	}
	return 0
}

type CreateClusterMsg struct {
	// Name of the cluster to be provisioned
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The provider specification
	Provider *CreateClusterProviderSpec `protobuf:"bytes,2,opt,name=provider" json:"provider,omitempty"`
}

func (m *CreateClusterMsg) Reset()                    { *m = CreateClusterMsg{} }
func (m *CreateClusterMsg) String() string            { return proto.CompactTextString(m) }
func (*CreateClusterMsg) ProtoMessage()               {}
func (*CreateClusterMsg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *CreateClusterMsg) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CreateClusterMsg) GetProvider() *CreateClusterProviderSpec {
	if m != nil {
		return m.Provider
	}
	return nil
}

type CreateClusterReply struct {
	// Whether or not the cluster was provisioned by this request
	Ok bool `protobuf:"varint,1,opt,name=ok" json:"ok,omitempty"`
	// Types that are valid to be assigned to ClusterOrError:
	//	*CreateClusterReply_Cluster
	//	*CreateClusterReply_Error
	ClusterOrError isCreateClusterReply_ClusterOrError `protobuf_oneof:"cluster_or_error"`
}

func (m *CreateClusterReply) Reset()                    { *m = CreateClusterReply{} }
func (m *CreateClusterReply) String() string            { return proto.CompactTextString(m) }
func (*CreateClusterReply) ProtoMessage()               {}
func (*CreateClusterReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

type isCreateClusterReply_ClusterOrError interface {
	isCreateClusterReply_ClusterOrError()
}

type CreateClusterReply_Cluster struct {
	Cluster *ClusterItem `protobuf:"bytes,2,opt,name=cluster,oneof"`
}
type CreateClusterReply_Error struct {
	Error *Error `protobuf:"bytes,7,opt,name=error,oneof"`
}

func (*CreateClusterReply_Cluster) isCreateClusterReply_ClusterOrError() {}
func (*CreateClusterReply_Error) isCreateClusterReply_ClusterOrError()   {}

func (m *CreateClusterReply) GetClusterOrError() isCreateClusterReply_ClusterOrError {
	if m != nil {
		return m.ClusterOrError
	}
	return nil
}

func (m *CreateClusterReply) GetOk() bool {
	if m != nil {
		return m.Ok
	}
	return false
}

func (m *CreateClusterReply) GetCluster() *ClusterItem {
	if x, ok := m.GetClusterOrError().(*CreateClusterReply_Cluster); ok {
		return x.Cluster
	}
	return nil
}

func (m *CreateClusterReply) GetError() *Error {
	if x, ok := m.GetClusterOrError().(*CreateClusterReply_Error); ok {
		return x.Error
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CreateClusterReply) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CreateClusterReply_OneofMarshaler, _CreateClusterReply_OneofUnmarshaler, _CreateClusterReply_OneofSizer, []interface{}{
		(*CreateClusterReply_Cluster)(nil),
		(*CreateClusterReply_Error)(nil),
	}
}

func _CreateClusterReply_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CreateClusterReply)
	// cluster_or_error
	switch x := m.ClusterOrError.(type) {
	case *CreateClusterReply_Cluster:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Cluster); err != nil {
			return err
		}
	case *CreateClusterReply_Error:
		b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Error); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("CreateClusterReply.ClusterOrError has unexpected type %T", x)
	}
	return nil
}

func _CreateClusterReply_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CreateClusterReply)
	switch tag {
	case 2: // cluster_or_error.cluster
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ClusterItem)
		err := b.DecodeMessage(msg)
		m.ClusterOrError = &CreateClusterReply_Cluster{msg}
		return true, err
	case 7: // cluster_or_error.error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Error)
		err := b.DecodeMessage(msg)
		m.ClusterOrError = &CreateClusterReply_Error{msg}
		return true, err
	default:
		return false, nil
	}
}

func _CreateClusterReply_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CreateClusterReply)
	// cluster_or_error
	switch x := m.ClusterOrError.(type) {
	case *CreateClusterReply_Cluster:
		s := proto.Size(x.Cluster)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *CreateClusterReply_Error:
		s := proto.Size(x.Error)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type GetClusterMsg struct {
	// Name of the cluster to be looked up
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *GetClusterMsg) Reset()                    { *m = GetClusterMsg{} }
func (m *GetClusterMsg) String() string            { return proto.CompactTextString(m) }
func (*GetClusterMsg) ProtoMessage()               {}
func (*GetClusterMsg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *GetClusterMsg) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type GetClusterReply struct {
	// Is the cluster in the system
	Ok bool `protobuf:"varint,1,opt,name=ok" json:"ok,omitempty"`
	// Types that are valid to be assigned to ClusterOrError:
	//	*GetClusterReply_Cluster
	//	*GetClusterReply_Error
	ClusterOrError isGetClusterReply_ClusterOrError `protobuf_oneof:"cluster_or_error"`
}

func (m *GetClusterReply) Reset()                    { *m = GetClusterReply{} }
func (m *GetClusterReply) String() string            { return proto.CompactTextString(m) }
func (*GetClusterReply) ProtoMessage()               {}
func (*GetClusterReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

type isGetClusterReply_ClusterOrError interface {
	isGetClusterReply_ClusterOrError()
}

type GetClusterReply_Cluster struct {
	Cluster *ClusterDetailItem `protobuf:"bytes,2,opt,name=cluster,oneof"`
}
type GetClusterReply_Error struct {
	Error *Error `protobuf:"bytes,7,opt,name=error,oneof"`
}

func (*GetClusterReply_Cluster) isGetClusterReply_ClusterOrError() {}
func (*GetClusterReply_Error) isGetClusterReply_ClusterOrError()   {}

func (m *GetClusterReply) GetClusterOrError() isGetClusterReply_ClusterOrError {
	if m != nil {
		return m.ClusterOrError
	}
	return nil
}

func (m *GetClusterReply) GetOk() bool {
	if m != nil {
		return m.Ok
	}
	return false
}

func (m *GetClusterReply) GetCluster() *ClusterDetailItem {
	if x, ok := m.GetClusterOrError().(*GetClusterReply_Cluster); ok {
		return x.Cluster
	}
	return nil
}

func (m *GetClusterReply) GetError() *Error {
	if x, ok := m.GetClusterOrError().(*GetClusterReply_Error); ok {
		return x.Error
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GetClusterReply) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _GetClusterReply_OneofMarshaler, _GetClusterReply_OneofUnmarshaler, _GetClusterReply_OneofSizer, []interface{}{
		(*GetClusterReply_Cluster)(nil),
		(*GetClusterReply_Error)(nil),
	}
}

func _GetClusterReply_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*GetClusterReply)
	// cluster_or_error
	switch x := m.ClusterOrError.(type) {
	case *GetClusterReply_Cluster:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Cluster); err != nil {
			return err
		}
	case *GetClusterReply_Error:
		b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Error); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GetClusterReply.ClusterOrError has unexpected type %T", x)
	}
	return nil
}

func _GetClusterReply_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*GetClusterReply)
	switch tag {
	case 2: // cluster_or_error.cluster
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ClusterDetailItem)
		err := b.DecodeMessage(msg)
		m.ClusterOrError = &GetClusterReply_Cluster{msg}
		return true, err
	case 7: // cluster_or_error.error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Error)
		err := b.DecodeMessage(msg)
		m.ClusterOrError = &GetClusterReply_Error{msg}
		return true, err
	default:
		return false, nil
	}
}

func _GetClusterReply_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*GetClusterReply)
	// cluster_or_error
	switch x := m.ClusterOrError.(type) {
	case *GetClusterReply_Cluster:
		s := proto.Size(x.Cluster)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *GetClusterReply_Error:
		s := proto.Size(x.Error)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type DeleteClusterMsg struct {
	// What is the cluster's name to destroy
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *DeleteClusterMsg) Reset()                    { *m = DeleteClusterMsg{} }
func (m *DeleteClusterMsg) String() string            { return proto.CompactTextString(m) }
func (*DeleteClusterMsg) ProtoMessage()               {}
func (*DeleteClusterMsg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *DeleteClusterMsg) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type DeleteClusterReply struct {
	// Could the cluster be destroyed
	Ok bool `protobuf:"varint,1,opt,name=ok" json:"ok,omitempty"`
	// Status of the request
	Status string `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *DeleteClusterReply) Reset()                    { *m = DeleteClusterReply{} }
func (m *DeleteClusterReply) String() string            { return proto.CompactTextString(m) }
func (*DeleteClusterReply) ProtoMessage()               {}
func (*DeleteClusterReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *DeleteClusterReply) GetOk() bool {
	if m != nil {
		return m.Ok
	}
	return false
}

func (m *DeleteClusterReply) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

type GetClusterListMsg struct {
}

func (m *GetClusterListMsg) Reset()                    { *m = GetClusterListMsg{} }
func (m *GetClusterListMsg) String() string            { return proto.CompactTextString(m) }
func (*GetClusterListMsg) ProtoMessage()               {}
func (*GetClusterListMsg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

type GetClusterListReply struct {
	// Is the cluster in the system
	Ok bool `protobuf:"varint,1,opt,name=ok" json:"ok,omitempty"`
	// List of clusters
	Clusters []*ClusterItem `protobuf:"bytes,2,rep,name=clusters" json:"clusters,omitempty"`
}

func (m *GetClusterListReply) Reset()                    { *m = GetClusterListReply{} }
func (m *GetClusterListReply) String() string            { return proto.CompactTextString(m) }
func (*GetClusterListReply) ProtoMessage()               {}
func (*GetClusterListReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *GetClusterListReply) GetOk() bool {
	if m != nil {
		return m.Ok
	}
	return false
}

func (m *GetClusterListReply) GetClusters() []*ClusterItem {
	if m != nil {
		return m.Clusters
	}
	return nil
}

type ClusterItem struct {
	// ID of the cluster
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// Name of the cluster
	Name string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// What is the status of the cluster
	Status string `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
}

func (m *ClusterItem) Reset()                    { *m = ClusterItem{} }
func (m *ClusterItem) String() string            { return proto.CompactTextString(m) }
func (*ClusterItem) ProtoMessage()               {}
func (*ClusterItem) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *ClusterItem) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ClusterItem) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ClusterItem) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

type ClusterDetailItem struct {
	// ID of the cluster
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// Name of the cluster
	Name string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// What is the status of the cluster
	Status string `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	// What is the kubeconfig to connect to the cluster
	Kubeconfig string `protobuf:"bytes,4,opt,name=kubeconfig" json:"kubeconfig,omitempty"`
}

func (m *ClusterDetailItem) Reset()                    { *m = ClusterDetailItem{} }
func (m *ClusterDetailItem) String() string            { return proto.CompactTextString(m) }
func (*ClusterDetailItem) ProtoMessage()               {}
func (*ClusterDetailItem) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *ClusterDetailItem) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ClusterDetailItem) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ClusterDetailItem) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *ClusterDetailItem) GetKubeconfig() string {
	if m != nil {
		return m.Kubeconfig
	}
	return ""
}

type Error struct {
	// The error code
	Code string `protobuf:"bytes,1,opt,name=code" json:"code,omitempty"`
	// The error message
	Message string `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
}

func (m *Error) Reset()                    { *m = Error{} }
func (m *Error) String() string            { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()               {}
func (*Error) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *Error) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *Error) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type ProvisionTillerMsg struct {
	// Cluster tiller should be installed on
	Cluster string `protobuf:"bytes,1,opt,name=cluster" json:"cluster,omitempty"`
	// Namespace tiller should be installed in
	Namespace string `protobuf:"bytes,2,opt,name=namespace" json:"namespace,omitempty"`
	// Versino of tiller/helm to install / upgrade to
	Version string `protobuf:"bytes,3,opt,name=version" json:"version,omitempty"`
	// Is the tiller a cluster-wide tiller?
	// Should it have cluster-wide admin privileges?
	ClusterWide bool `protobuf:"varint,4,opt,name=cluster_wide,json=clusterWide" json:"cluster_wide,omitempty"`
	// Namespaces that it should be able to admin on
	AdminNamespaces []string `protobuf:"bytes,5,rep,name=admin_namespaces,json=adminNamespaces" json:"admin_namespaces,omitempty"`
}

func (m *ProvisionTillerMsg) Reset()                    { *m = ProvisionTillerMsg{} }
func (m *ProvisionTillerMsg) String() string            { return proto.CompactTextString(m) }
func (*ProvisionTillerMsg) ProtoMessage()               {}
func (*ProvisionTillerMsg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *ProvisionTillerMsg) GetCluster() string {
	if m != nil {
		return m.Cluster
	}
	return ""
}

func (m *ProvisionTillerMsg) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ProvisionTillerMsg) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *ProvisionTillerMsg) GetClusterWide() bool {
	if m != nil {
		return m.ClusterWide
	}
	return false
}

func (m *ProvisionTillerMsg) GetAdminNamespaces() []string {
	if m != nil {
		return m.AdminNamespaces
	}
	return nil
}

type ProvisionTillerReply struct {
	// Was the operation successful
	Ok bool `protobuf:"varint,1,opt,name=ok" json:"ok,omitempty"`
	// What messages were given
	Message string `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
}

func (m *ProvisionTillerReply) Reset()                    { *m = ProvisionTillerReply{} }
func (m *ProvisionTillerReply) String() string            { return proto.CompactTextString(m) }
func (*ProvisionTillerReply) ProtoMessage()               {}
func (*ProvisionTillerReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *ProvisionTillerReply) GetOk() bool {
	if m != nil {
		return m.Ok
	}
	return false
}

func (m *ProvisionTillerReply) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type InstallHelmChartMsg struct {
	// Cluster tiller should be installed on
	Cluster string `protobuf:"bytes,1,opt,name=cluster" json:"cluster,omitempty"`
	// Tiller settings
	Tiller *GenericTillerSetting `protobuf:"bytes,2,opt,name=tiller" json:"tiller,omitempty"`
	// Chart Settings
	Chart *GenericHelmChart `protobuf:"bytes,3,opt,name=chart" json:"chart,omitempty"`
}

func (m *InstallHelmChartMsg) Reset()                    { *m = InstallHelmChartMsg{} }
func (m *InstallHelmChartMsg) String() string            { return proto.CompactTextString(m) }
func (*InstallHelmChartMsg) ProtoMessage()               {}
func (*InstallHelmChartMsg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *InstallHelmChartMsg) GetCluster() string {
	if m != nil {
		return m.Cluster
	}
	return ""
}

func (m *InstallHelmChartMsg) GetTiller() *GenericTillerSetting {
	if m != nil {
		return m.Tiller
	}
	return nil
}

func (m *InstallHelmChartMsg) GetChart() *GenericHelmChart {
	if m != nil {
		return m.Chart
	}
	return nil
}

type InstallHelmChartReply struct {
	// Was the operation successful
	Ok bool `protobuf:"varint,1,opt,name=ok" json:"ok,omitempty"`
	// What messages were given
	Message string `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
}

func (m *InstallHelmChartReply) Reset()                    { *m = InstallHelmChartReply{} }
func (m *InstallHelmChartReply) String() string            { return proto.CompactTextString(m) }
func (*InstallHelmChartReply) ProtoMessage()               {}
func (*InstallHelmChartReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *InstallHelmChartReply) GetOk() bool {
	if m != nil {
		return m.Ok
	}
	return false
}

func (m *InstallHelmChartReply) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type DeleteHelmChartMsg struct {
	// Cluster tiller should be installed on
	Cluster string `protobuf:"bytes,1,opt,name=cluster" json:"cluster,omitempty"`
	// Tiller settings
	Tiller *GenericTillerSetting `protobuf:"bytes,2,opt,name=tiller" json:"tiller,omitempty"`
	// Chart Name
	Chart string `protobuf:"bytes,3,opt,name=chart" json:"chart,omitempty"`
}

func (m *DeleteHelmChartMsg) Reset()                    { *m = DeleteHelmChartMsg{} }
func (m *DeleteHelmChartMsg) String() string            { return proto.CompactTextString(m) }
func (*DeleteHelmChartMsg) ProtoMessage()               {}
func (*DeleteHelmChartMsg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *DeleteHelmChartMsg) GetCluster() string {
	if m != nil {
		return m.Cluster
	}
	return ""
}

func (m *DeleteHelmChartMsg) GetTiller() *GenericTillerSetting {
	if m != nil {
		return m.Tiller
	}
	return nil
}

func (m *DeleteHelmChartMsg) GetChart() string {
	if m != nil {
		return m.Chart
	}
	return ""
}

type DeleteHelmChartReply struct {
	// Was the operation successful
	Ok bool `protobuf:"varint,1,opt,name=ok" json:"ok,omitempty"`
	// What messages were given
	Message string `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
}

func (m *DeleteHelmChartReply) Reset()                    { *m = DeleteHelmChartReply{} }
func (m *DeleteHelmChartReply) String() string            { return proto.CompactTextString(m) }
func (*DeleteHelmChartReply) ProtoMessage()               {}
func (*DeleteHelmChartReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *DeleteHelmChartReply) GetOk() bool {
	if m != nil {
		return m.Ok
	}
	return false
}

func (m *DeleteHelmChartReply) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type GenericTillerSetting struct {
	// What is the tiller namespace
	Namespace string `protobuf:"bytes,1,opt,name=namespace" json:"namespace,omitempty"`
	// What is the version of tiller/helm
	Version string `protobuf:"bytes,2,opt,name=version" json:"version,omitempty"`
}

func (m *GenericTillerSetting) Reset()                    { *m = GenericTillerSetting{} }
func (m *GenericTillerSetting) String() string            { return proto.CompactTextString(m) }
func (*GenericTillerSetting) ProtoMessage()               {}
func (*GenericTillerSetting) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *GenericTillerSetting) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *GenericTillerSetting) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

type GenericHelmChart struct {
	// What is the name of the deployment
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// What is the namespace to deploy the application to
	Namespace string `protobuf:"bytes,2,opt,name=namespace" json:"namespace,omitempty"`
	// What is the chart repository
	Repo string `protobuf:"bytes,3,opt,name=repo" json:"repo,omitempty"`
	// What is the chart name
	Chart string `protobuf:"bytes,4,opt,name=chart" json:"chart,omitempty"`
	// What are the options (nested yaml - the Values.yaml contents)
	Values string `protobuf:"bytes,5,opt,name=values" json:"values,omitempty"`
}

func (m *GenericHelmChart) Reset()                    { *m = GenericHelmChart{} }
func (m *GenericHelmChart) String() string            { return proto.CompactTextString(m) }
func (*GenericHelmChart) ProtoMessage()               {}
func (*GenericHelmChart) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *GenericHelmChart) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GenericHelmChart) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *GenericHelmChart) GetRepo() string {
	if m != nil {
		return m.Repo
	}
	return ""
}

func (m *GenericHelmChart) GetChart() string {
	if m != nil {
		return m.Chart
	}
	return ""
}

func (m *GenericHelmChart) GetValues() string {
	if m != nil {
		return m.Values
	}
	return ""
}

type CreateClusterProviderSpec struct {
	// What is the provider - currently this is aws or maas
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The MaaS specification
	Maas *CreateClusterMaaSSpec `protobuf:"bytes,2,opt,name=maas" json:"maas,omitempty"`
	// The AWS specification
	Aws *CreateClusterAWSSpec `protobuf:"bytes,3,opt,name=aws" json:"aws,omitempty"`
}

func (m *CreateClusterProviderSpec) Reset()                    { *m = CreateClusterProviderSpec{} }
func (m *CreateClusterProviderSpec) String() string            { return proto.CompactTextString(m) }
func (*CreateClusterProviderSpec) ProtoMessage()               {}
func (*CreateClusterProviderSpec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *CreateClusterProviderSpec) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CreateClusterProviderSpec) GetMaas() *CreateClusterMaaSSpec {
	if m != nil {
		return m.Maas
	}
	return nil
}

func (m *CreateClusterProviderSpec) GetAws() *CreateClusterAWSSpec {
	if m != nil {
		return m.Aws
	}
	return nil
}

type CreateClusterMaaSSpec struct {
	// The MaaS API endpoint
	Endpoint string `protobuf:"bytes,1,opt,name=endpoint" json:"endpoint,omitempty"`
	// The username in the MaaS API
	Username string `protobuf:"bytes,2,opt,name=username" json:"username,omitempty"`
	// The OAuth key for the endpoint
	OauthKey string `protobuf:"bytes,3,opt,name=oauth_key,json=oauthKey" json:"oauth_key,omitempty"`
}

func (m *CreateClusterMaaSSpec) Reset()                    { *m = CreateClusterMaaSSpec{} }
func (m *CreateClusterMaaSSpec) String() string            { return proto.CompactTextString(m) }
func (*CreateClusterMaaSSpec) ProtoMessage()               {}
func (*CreateClusterMaaSSpec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *CreateClusterMaaSSpec) GetEndpoint() string {
	if m != nil {
		return m.Endpoint
	}
	return ""
}

func (m *CreateClusterMaaSSpec) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *CreateClusterMaaSSpec) GetOauthKey() string {
	if m != nil {
		return m.OauthKey
	}
	return ""
}

type CreateClusterAWSSpec struct {
	// The region for AWS
	Region string `protobuf:"bytes,1,opt,name=region" json:"region,omitempty"`
	// The SecretKeyId for API Access
	SecretKeyId string `protobuf:"bytes,2,opt,name=secret_key_id,json=secretKeyId" json:"secret_key_id,omitempty"`
	// The SecretAccessKey for API access
	SecretAccessKey string `protobuf:"bytes,3,opt,name=secret_access_key,json=secretAccessKey" json:"secret_access_key,omitempty"`
}

func (m *CreateClusterAWSSpec) Reset()                    { *m = CreateClusterAWSSpec{} }
func (m *CreateClusterAWSSpec) String() string            { return proto.CompactTextString(m) }
func (*CreateClusterAWSSpec) ProtoMessage()               {}
func (*CreateClusterAWSSpec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *CreateClusterAWSSpec) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *CreateClusterAWSSpec) GetSecretKeyId() string {
	if m != nil {
		return m.SecretKeyId
	}
	return ""
}

func (m *CreateClusterAWSSpec) GetSecretAccessKey() string {
	if m != nil {
		return m.SecretAccessKey
	}
	return ""
}

type GetVersionMsg struct {
}

func (m *GetVersionMsg) Reset()                    { *m = GetVersionMsg{} }
func (m *GetVersionMsg) String() string            { return proto.CompactTextString(m) }
func (*GetVersionMsg) ProtoMessage()               {}
func (*GetVersionMsg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

type GetVersionReply struct {
	// If operation was OK
	Ok bool `protobuf:"varint,1,opt,name=ok" json:"ok,omitempty"`
	// Version Information
	VersionInformation *GetVersionReply_VersionInformation `protobuf:"bytes,2,opt,name=version_information,json=versionInformation" json:"version_information,omitempty"`
}

func (m *GetVersionReply) Reset()                    { *m = GetVersionReply{} }
func (m *GetVersionReply) String() string            { return proto.CompactTextString(m) }
func (*GetVersionReply) ProtoMessage()               {}
func (*GetVersionReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

func (m *GetVersionReply) GetOk() bool {
	if m != nil {
		return m.Ok
	}
	return false
}

func (m *GetVersionReply) GetVersionInformation() *GetVersionReply_VersionInformation {
	if m != nil {
		return m.VersionInformation
	}
	return nil
}

type GetVersionReply_VersionInformation struct {
	// The tag on the git repository
	GitVersion string `protobuf:"bytes,1,opt,name=git_version,json=gitVersion" json:"git_version,omitempty"`
	// The hash of the git commit
	GitCommit string `protobuf:"bytes,2,opt,name=git_commit,json=gitCommit" json:"git_commit,omitempty"`
	// Whether or not the tree was clean when built
	GitTreeState string `protobuf:"bytes,3,opt,name=git_tree_state,json=gitTreeState" json:"git_tree_state,omitempty"`
	// Date of build
	BuildDate string `protobuf:"bytes,4,opt,name=build_date,json=buildDate" json:"build_date,omitempty"`
	// Version of go used to compile
	GoVersion string `protobuf:"bytes,5,opt,name=go_version,json=goVersion" json:"go_version,omitempty"`
	// Compiler used
	Compiler string `protobuf:"bytes,6,opt,name=compiler" json:"compiler,omitempty"`
	// Platform it was compiled for / running on
	Platform string `protobuf:"bytes,7,opt,name=platform" json:"platform,omitempty"`
}

func (m *GetVersionReply_VersionInformation) Reset()         { *m = GetVersionReply_VersionInformation{} }
func (m *GetVersionReply_VersionInformation) String() string { return proto.CompactTextString(m) }
func (*GetVersionReply_VersionInformation) ProtoMessage()    {}
func (*GetVersionReply_VersionInformation) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{27, 0}
}

func (m *GetVersionReply_VersionInformation) GetGitVersion() string {
	if m != nil {
		return m.GitVersion
	}
	return ""
}

func (m *GetVersionReply_VersionInformation) GetGitCommit() string {
	if m != nil {
		return m.GitCommit
	}
	return ""
}

func (m *GetVersionReply_VersionInformation) GetGitTreeState() string {
	if m != nil {
		return m.GitTreeState
	}
	return ""
}

func (m *GetVersionReply_VersionInformation) GetBuildDate() string {
	if m != nil {
		return m.BuildDate
	}
	return ""
}

func (m *GetVersionReply_VersionInformation) GetGoVersion() string {
	if m != nil {
		return m.GoVersion
	}
	return ""
}

func (m *GetVersionReply_VersionInformation) GetCompiler() string {
	if m != nil {
		return m.Compiler
	}
	return ""
}

func (m *GetVersionReply_VersionInformation) GetPlatform() string {
	if m != nil {
		return m.Platform
	}
	return ""
}

func init() {
	proto.RegisterType((*HelloWorldMsg)(nil), "cluster_manager_api.HelloWorldMsg")
	proto.RegisterType((*HelloWorldReply)(nil), "cluster_manager_api.HelloWorldReply")
	proto.RegisterType((*GetPodCountMsg)(nil), "cluster_manager_api.GetPodCountMsg")
	proto.RegisterType((*GetPodCountReply)(nil), "cluster_manager_api.GetPodCountReply")
	proto.RegisterType((*CreateClusterMsg)(nil), "cluster_manager_api.CreateClusterMsg")
	proto.RegisterType((*CreateClusterReply)(nil), "cluster_manager_api.CreateClusterReply")
	proto.RegisterType((*GetClusterMsg)(nil), "cluster_manager_api.GetClusterMsg")
	proto.RegisterType((*GetClusterReply)(nil), "cluster_manager_api.GetClusterReply")
	proto.RegisterType((*DeleteClusterMsg)(nil), "cluster_manager_api.DeleteClusterMsg")
	proto.RegisterType((*DeleteClusterReply)(nil), "cluster_manager_api.DeleteClusterReply")
	proto.RegisterType((*GetClusterListMsg)(nil), "cluster_manager_api.GetClusterListMsg")
	proto.RegisterType((*GetClusterListReply)(nil), "cluster_manager_api.GetClusterListReply")
	proto.RegisterType((*ClusterItem)(nil), "cluster_manager_api.ClusterItem")
	proto.RegisterType((*ClusterDetailItem)(nil), "cluster_manager_api.ClusterDetailItem")
	proto.RegisterType((*Error)(nil), "cluster_manager_api.Error")
	proto.RegisterType((*ProvisionTillerMsg)(nil), "cluster_manager_api.ProvisionTillerMsg")
	proto.RegisterType((*ProvisionTillerReply)(nil), "cluster_manager_api.ProvisionTillerReply")
	proto.RegisterType((*InstallHelmChartMsg)(nil), "cluster_manager_api.InstallHelmChartMsg")
	proto.RegisterType((*InstallHelmChartReply)(nil), "cluster_manager_api.InstallHelmChartReply")
	proto.RegisterType((*DeleteHelmChartMsg)(nil), "cluster_manager_api.DeleteHelmChartMsg")
	proto.RegisterType((*DeleteHelmChartReply)(nil), "cluster_manager_api.DeleteHelmChartReply")
	proto.RegisterType((*GenericTillerSetting)(nil), "cluster_manager_api.GenericTillerSetting")
	proto.RegisterType((*GenericHelmChart)(nil), "cluster_manager_api.GenericHelmChart")
	proto.RegisterType((*CreateClusterProviderSpec)(nil), "cluster_manager_api.CreateClusterProviderSpec")
	proto.RegisterType((*CreateClusterMaaSSpec)(nil), "cluster_manager_api.CreateClusterMaaSSpec")
	proto.RegisterType((*CreateClusterAWSSpec)(nil), "cluster_manager_api.CreateClusterAWSSpec")
	proto.RegisterType((*GetVersionMsg)(nil), "cluster_manager_api.GetVersionMsg")
	proto.RegisterType((*GetVersionReply)(nil), "cluster_manager_api.GetVersionReply")
	proto.RegisterType((*GetVersionReply_VersionInformation)(nil), "cluster_manager_api.GetVersionReply.VersionInformation")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Cluster service

type ClusterClient interface {
	// Simple Hello World Service - will repeat a greeting to the name provided
	HelloWorld(ctx context.Context, in *HelloWorldMsg, opts ...grpc.CallOption) (*HelloWorldReply, error)
	// Simple pod count response.  Will respond with the number of pods in the namespace provided
	GetPodCount(ctx context.Context, in *GetPodCountMsg, opts ...grpc.CallOption) (*GetPodCountReply, error)
	// Will provision a cluster
	CreateCluster(ctx context.Context, in *CreateClusterMsg, opts ...grpc.CallOption) (*CreateClusterReply, error)
	// Will retrieve the status of a cluster and its kubeconfig for connectivity
	GetCluster(ctx context.Context, in *GetClusterMsg, opts ...grpc.CallOption) (*GetClusterReply, error)
	// Will delete a cluster
	DeleteCluster(ctx context.Context, in *DeleteClusterMsg, opts ...grpc.CallOption) (*DeleteClusterReply, error)
	// Will retrieve a list of clusters
	GetClusterList(ctx context.Context, in *GetClusterListMsg, opts ...grpc.CallOption) (*GetClusterListReply, error)
	// Will install (or reinstall) tiller
	ProvisionTiller(ctx context.Context, in *ProvisionTillerMsg, opts ...grpc.CallOption) (*ProvisionTillerReply, error)
	// Will install (or reinstall) helm chart
	// This will be destructive if a chart has already been deployed with the same name
	InstallHelmChart(ctx context.Context, in *InstallHelmChartMsg, opts ...grpc.CallOption) (*InstallHelmChartReply, error)
	// Will delete deployed helm chart
	DeleteHelmChart(ctx context.Context, in *DeleteHelmChartMsg, opts ...grpc.CallOption) (*DeleteHelmChartReply, error)
	// Will return version information about api server
	GetVersionInformation(ctx context.Context, in *GetVersionMsg, opts ...grpc.CallOption) (*GetVersionReply, error)
}

type clusterClient struct {
	cc *grpc.ClientConn
}

func NewClusterClient(cc *grpc.ClientConn) ClusterClient {
	return &clusterClient{cc}
}

func (c *clusterClient) HelloWorld(ctx context.Context, in *HelloWorldMsg, opts ...grpc.CallOption) (*HelloWorldReply, error) {
	out := new(HelloWorldReply)
	err := grpc.Invoke(ctx, "/cluster_manager_api.Cluster/HelloWorld", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterClient) GetPodCount(ctx context.Context, in *GetPodCountMsg, opts ...grpc.CallOption) (*GetPodCountReply, error) {
	out := new(GetPodCountReply)
	err := grpc.Invoke(ctx, "/cluster_manager_api.Cluster/GetPodCount", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterClient) CreateCluster(ctx context.Context, in *CreateClusterMsg, opts ...grpc.CallOption) (*CreateClusterReply, error) {
	out := new(CreateClusterReply)
	err := grpc.Invoke(ctx, "/cluster_manager_api.Cluster/CreateCluster", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterClient) GetCluster(ctx context.Context, in *GetClusterMsg, opts ...grpc.CallOption) (*GetClusterReply, error) {
	out := new(GetClusterReply)
	err := grpc.Invoke(ctx, "/cluster_manager_api.Cluster/GetCluster", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterClient) DeleteCluster(ctx context.Context, in *DeleteClusterMsg, opts ...grpc.CallOption) (*DeleteClusterReply, error) {
	out := new(DeleteClusterReply)
	err := grpc.Invoke(ctx, "/cluster_manager_api.Cluster/DeleteCluster", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterClient) GetClusterList(ctx context.Context, in *GetClusterListMsg, opts ...grpc.CallOption) (*GetClusterListReply, error) {
	out := new(GetClusterListReply)
	err := grpc.Invoke(ctx, "/cluster_manager_api.Cluster/GetClusterList", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterClient) ProvisionTiller(ctx context.Context, in *ProvisionTillerMsg, opts ...grpc.CallOption) (*ProvisionTillerReply, error) {
	out := new(ProvisionTillerReply)
	err := grpc.Invoke(ctx, "/cluster_manager_api.Cluster/ProvisionTiller", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterClient) InstallHelmChart(ctx context.Context, in *InstallHelmChartMsg, opts ...grpc.CallOption) (*InstallHelmChartReply, error) {
	out := new(InstallHelmChartReply)
	err := grpc.Invoke(ctx, "/cluster_manager_api.Cluster/InstallHelmChart", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterClient) DeleteHelmChart(ctx context.Context, in *DeleteHelmChartMsg, opts ...grpc.CallOption) (*DeleteHelmChartReply, error) {
	out := new(DeleteHelmChartReply)
	err := grpc.Invoke(ctx, "/cluster_manager_api.Cluster/DeleteHelmChart", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterClient) GetVersionInformation(ctx context.Context, in *GetVersionMsg, opts ...grpc.CallOption) (*GetVersionReply, error) {
	out := new(GetVersionReply)
	err := grpc.Invoke(ctx, "/cluster_manager_api.Cluster/GetVersionInformation", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Cluster service

type ClusterServer interface {
	// Simple Hello World Service - will repeat a greeting to the name provided
	HelloWorld(context.Context, *HelloWorldMsg) (*HelloWorldReply, error)
	// Simple pod count response.  Will respond with the number of pods in the namespace provided
	GetPodCount(context.Context, *GetPodCountMsg) (*GetPodCountReply, error)
	// Will provision a cluster
	CreateCluster(context.Context, *CreateClusterMsg) (*CreateClusterReply, error)
	// Will retrieve the status of a cluster and its kubeconfig for connectivity
	GetCluster(context.Context, *GetClusterMsg) (*GetClusterReply, error)
	// Will delete a cluster
	DeleteCluster(context.Context, *DeleteClusterMsg) (*DeleteClusterReply, error)
	// Will retrieve a list of clusters
	GetClusterList(context.Context, *GetClusterListMsg) (*GetClusterListReply, error)
	// Will install (or reinstall) tiller
	ProvisionTiller(context.Context, *ProvisionTillerMsg) (*ProvisionTillerReply, error)
	// Will install (or reinstall) helm chart
	// This will be destructive if a chart has already been deployed with the same name
	InstallHelmChart(context.Context, *InstallHelmChartMsg) (*InstallHelmChartReply, error)
	// Will delete deployed helm chart
	DeleteHelmChart(context.Context, *DeleteHelmChartMsg) (*DeleteHelmChartReply, error)
	// Will return version information about api server
	GetVersionInformation(context.Context, *GetVersionMsg) (*GetVersionReply, error)
}

func RegisterClusterServer(s *grpc.Server, srv ClusterServer) {
	s.RegisterService(&_Cluster_serviceDesc, srv)
}

func _Cluster_HelloWorld_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HelloWorldMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServer).HelloWorld(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cluster_manager_api.Cluster/HelloWorld",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServer).HelloWorld(ctx, req.(*HelloWorldMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cluster_GetPodCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPodCountMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServer).GetPodCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cluster_manager_api.Cluster/GetPodCount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServer).GetPodCount(ctx, req.(*GetPodCountMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cluster_CreateCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateClusterMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServer).CreateCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cluster_manager_api.Cluster/CreateCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServer).CreateCluster(ctx, req.(*CreateClusterMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cluster_GetCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClusterMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServer).GetCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cluster_manager_api.Cluster/GetCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServer).GetCluster(ctx, req.(*GetClusterMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cluster_DeleteCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteClusterMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServer).DeleteCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cluster_manager_api.Cluster/DeleteCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServer).DeleteCluster(ctx, req.(*DeleteClusterMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cluster_GetClusterList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClusterListMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServer).GetClusterList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cluster_manager_api.Cluster/GetClusterList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServer).GetClusterList(ctx, req.(*GetClusterListMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cluster_ProvisionTiller_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProvisionTillerMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServer).ProvisionTiller(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cluster_manager_api.Cluster/ProvisionTiller",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServer).ProvisionTiller(ctx, req.(*ProvisionTillerMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cluster_InstallHelmChart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstallHelmChartMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServer).InstallHelmChart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cluster_manager_api.Cluster/InstallHelmChart",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServer).InstallHelmChart(ctx, req.(*InstallHelmChartMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cluster_DeleteHelmChart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteHelmChartMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServer).DeleteHelmChart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cluster_manager_api.Cluster/DeleteHelmChart",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServer).DeleteHelmChart(ctx, req.(*DeleteHelmChartMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cluster_GetVersionInformation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVersionMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterServer).GetVersionInformation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cluster_manager_api.Cluster/GetVersionInformation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterServer).GetVersionInformation(ctx, req.(*GetVersionMsg))
	}
	return interceptor(ctx, in, info, handler)
}

var _Cluster_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cluster_manager_api.Cluster",
	HandlerType: (*ClusterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "HelloWorld",
			Handler:    _Cluster_HelloWorld_Handler,
		},
		{
			MethodName: "GetPodCount",
			Handler:    _Cluster_GetPodCount_Handler,
		},
		{
			MethodName: "CreateCluster",
			Handler:    _Cluster_CreateCluster_Handler,
		},
		{
			MethodName: "GetCluster",
			Handler:    _Cluster_GetCluster_Handler,
		},
		{
			MethodName: "DeleteCluster",
			Handler:    _Cluster_DeleteCluster_Handler,
		},
		{
			MethodName: "GetClusterList",
			Handler:    _Cluster_GetClusterList_Handler,
		},
		{
			MethodName: "ProvisionTiller",
			Handler:    _Cluster_ProvisionTiller_Handler,
		},
		{
			MethodName: "InstallHelmChart",
			Handler:    _Cluster_InstallHelmChart_Handler,
		},
		{
			MethodName: "DeleteHelmChart",
			Handler:    _Cluster_DeleteHelmChart_Handler,
		},
		{
			MethodName: "GetVersionInformation",
			Handler:    _Cluster_GetVersionInformation_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}

func init() { proto.RegisterFile("api.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1456 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x58, 0x5f, 0x6f, 0x1b, 0x45,
	0x10, 0xef, 0x39, 0x7f, 0x3d, 0x69, 0xe2, 0x64, 0xed, 0xb6, 0xee, 0xd1, 0x16, 0x73, 0x6d, 0x43,
	0x62, 0x88, 0xdd, 0xa6, 0x42, 0x48, 0x6d, 0x85, 0xea, 0xa6, 0xa8, 0x09, 0x25, 0x55, 0x75, 0x29,
	0xed, 0xa3, 0xd9, 0xdc, 0x6d, 0xcf, 0x4b, 0xee, 0x6e, 0x4f, 0x77, 0x6b, 0x87, 0x14, 0x09, 0x15,
	0x1e, 0xe0, 0x1d, 0xbe, 0x05, 0x02, 0xf1, 0xc2, 0x37, 0xe1, 0x13, 0x20, 0x01, 0xcf, 0x7c, 0x02,
	0x84, 0x76, 0x6f, 0xcf, 0xbe, 0xb3, 0xcf, 0x76, 0x2a, 0x04, 0x4f, 0xb9, 0x9d, 0x9d, 0x99, 0xdf,
	0xfc, 0x66, 0x66, 0x77, 0x27, 0x86, 0x22, 0x0e, 0x68, 0x23, 0x08, 0x19, 0x67, 0xa8, 0x6c, 0xb9,
	0xdd, 0x88, 0x93, 0xb0, 0xed, 0x61, 0x1f, 0x3b, 0x24, 0x6c, 0xe3, 0x80, 0xea, 0x97, 0x1c, 0xc6,
	0x1c, 0x97, 0x34, 0x71, 0x40, 0x9b, 0xd8, 0xf7, 0x19, 0xc7, 0x9c, 0x32, 0x3f, 0x8a, 0x4d, 0xf4,
	0x77, 0xe5, 0x1f, 0x6b, 0xcb, 0x21, 0xfe, 0x56, 0x74, 0x8c, 0x1d, 0x87, 0x84, 0x4d, 0x16, 0x48,
	0x8d, 0x51, 0x6d, 0xe3, 0x2a, 0x2c, 0xef, 0x12, 0xd7, 0x65, 0xcf, 0x59, 0xe8, 0xda, 0xfb, 0x91,
	0x83, 0x10, 0xcc, 0xfa, 0xd8, 0x23, 0x55, 0xad, 0xa6, 0x6d, 0x14, 0x4d, 0xf9, 0x6d, 0xbc, 0x03,
	0xa5, 0x81, 0x92, 0x49, 0x02, 0xf7, 0x04, 0x55, 0x61, 0xc1, 0x23, 0x51, 0x84, 0x9d, 0x44, 0x33,
	0x59, 0x1a, 0x0d, 0x58, 0x79, 0x48, 0xf8, 0x13, 0x66, 0xef, 0xb0, 0xae, 0xcf, 0x85, 0xcb, 0x4b,
	0x50, 0x14, 0x6e, 0xa2, 0x00, 0x5b, 0x89, 0xf6, 0x40, 0x60, 0xac, 0xc3, 0x6a, 0x4a, 0x3f, 0xf6,
	0x8e, 0x60, 0x36, 0x60, 0x76, 0x24, 0x95, 0xe7, 0x4c, 0xf9, 0x6d, 0x84, 0xb0, 0xba, 0x13, 0x12,
	0xcc, 0xc9, 0x4e, 0x9c, 0x92, 0x31, 0xc1, 0xa2, 0x8f, 0x60, 0x31, 0x08, 0x59, 0x8f, 0xda, 0x24,
	0xac, 0x16, 0x6a, 0xda, 0xc6, 0xd2, 0x76, 0xa3, 0x91, 0x93, 0xc5, 0x46, 0xc6, 0xd9, 0x13, 0x65,
	0x71, 0x10, 0x10, 0xcb, 0xec, 0xdb, 0x1b, 0x3f, 0x68, 0x80, 0x32, 0x7a, 0x71, 0x78, 0x2b, 0x50,
	0x60, 0x47, 0x12, 0x74, 0xd1, 0x2c, 0xb0, 0x23, 0x74, 0x17, 0x16, 0x14, 0x82, 0x42, 0xac, 0xe5,
	0x23, 0xc6, 0xb2, 0x3d, 0x4e, 0xbc, 0xdd, 0x33, 0x66, 0x62, 0x82, 0xb6, 0x61, 0x8e, 0x84, 0x21,
	0x0b, 0xab, 0x0b, 0xd2, 0x56, 0xcf, 0xb5, 0xfd, 0x50, 0x68, 0xec, 0x9e, 0x31, 0x63, 0xd5, 0xfb,
	0x08, 0x56, 0x13, 0x2d, 0x16, 0xb6, 0xa5, 0x4c, 0x94, 0xf2, 0x21, 0xe1, 0x93, 0xb3, 0x63, 0xfc,
	0xa4, 0x41, 0x69, 0xa0, 0x95, 0x4f, 0xe7, 0xfe, 0x30, 0x9d, 0xf5, 0x49, 0x74, 0x1e, 0x10, 0x8e,
	0xa9, 0xfb, 0x5f, 0x91, 0x5a, 0x87, 0xd5, 0x07, 0xc4, 0x25, 0xd3, 0xaa, 0x6e, 0xdc, 0x05, 0x94,
	0xd1, 0xcb, 0x67, 0x76, 0x1e, 0xe6, 0x23, 0x8e, 0x79, 0x37, 0x92, 0xc4, 0x8a, 0xa6, 0x5a, 0x19,
	0x65, 0x58, 0x1b, 0x24, 0xe5, 0x63, 0x1a, 0x89, 0xb6, 0x35, 0x2c, 0x28, 0x67, 0x85, 0xe3, 0x8a,
	0xbf, 0xa8, 0xa2, 0x16, 0x5e, 0x67, 0x4e, 0x53, 0x7d, 0xb3, 0x6f, 0x61, 0xec, 0xc1, 0x52, 0x6a,
	0x43, 0x38, 0xa7, 0xb6, 0x22, 0x56, 0xa0, 0x76, 0x9f, 0x6a, 0x21, 0xd5, 0xe0, 0x03, 0x12, 0x33,
	0x19, 0x12, 0x0c, 0xd6, 0x46, 0x4a, 0xf2, 0x6f, 0x1c, 0xa2, 0x2b, 0x00, 0x47, 0xdd, 0x43, 0x62,
	0x31, 0xff, 0x05, 0x75, 0xaa, 0xb3, 0x72, 0x2f, 0x25, 0x31, 0xde, 0x83, 0x39, 0x59, 0x41, 0xe1,
	0xd4, 0x62, 0x76, 0xbf, 0x20, 0xe2, 0x3b, 0x7d, 0x41, 0x14, 0xb2, 0x17, 0xc4, 0x2f, 0x1a, 0x20,
	0x79, 0xde, 0x22, 0xca, 0xfc, 0xa7, 0xd4, 0x75, 0xe3, 0xaa, 0x56, 0x07, 0x5d, 0xa7, 0x6e, 0x94,
	0xa4, 0x97, 0x32, 0xf7, 0x47, 0x61, 0xe8, 0xfe, 0x10, 0x76, 0x3d, 0x12, 0x0a, 0x5f, 0x2a, 0xfc,
	0x64, 0x89, 0xde, 0x82, 0xb3, 0x49, 0x21, 0x8e, 0xa9, 0x4d, 0x24, 0x83, 0x45, 0x73, 0x49, 0xc9,
	0x9e, 0x53, 0x9b, 0xa0, 0x4d, 0x58, 0xc5, 0xb6, 0x47, 0xfd, 0x76, 0xdf, 0x5f, 0x54, 0x9d, 0xab,
	0xcd, 0x6c, 0x14, 0xcd, 0x92, 0x94, 0x3f, 0xee, 0x8b, 0x8d, 0x7b, 0x50, 0x19, 0x8a, 0x3a, 0xbf,
	0x1f, 0xc6, 0x13, 0xff, 0x59, 0x83, 0xf2, 0x9e, 0x1f, 0x71, 0xec, 0xba, 0xbb, 0xc4, 0xf5, 0x76,
	0x3a, 0x38, 0xe4, 0x93, 0x99, 0xb7, 0x60, 0x9e, 0x4b, 0x28, 0x75, 0x10, 0x37, 0x73, 0x3b, 0xeb,
	0x21, 0xf1, 0x49, 0x48, 0xad, 0x38, 0xa8, 0x03, 0xc2, 0x39, 0xf5, 0x1d, 0x53, 0x19, 0xa2, 0x3b,
	0x30, 0x67, 0x09, 0x20, 0x99, 0x9c, 0xa5, 0xed, 0xeb, 0x93, 0x3c, 0xf4, 0xa3, 0x32, 0x63, 0x1b,
	0xa3, 0x05, 0xe7, 0x86, 0x03, 0x7e, 0x5d, 0xd2, 0xdf, 0x6a, 0xc9, 0xc9, 0xfc, 0xff, 0x38, 0x57,
	0xd2, 0x9c, 0x8b, 0x09, 0x99, 0x7b, 0x50, 0x19, 0x0a, 0xe4, 0x75, 0xb9, 0x3c, 0x86, 0x4a, 0x1e,
	0xee, 0xe4, 0x07, 0x2e, 0xdd, 0xa0, 0x85, 0x4c, 0x83, 0x1a, 0xdf, 0x68, 0xe2, 0xed, 0xcb, 0xa6,
	0x3e, 0xf7, 0x4d, 0x9b, 0x7c, 0x02, 0x10, 0xcc, 0x86, 0x24, 0x60, 0x8a, 0xad, 0xfc, 0x1e, 0xa4,
	0x60, 0x36, 0x95, 0x02, 0x71, 0xd2, 0x7b, 0xd8, 0xed, 0xca, 0x26, 0x97, 0x27, 0x3d, 0x5e, 0x19,
	0x3f, 0x6a, 0x70, 0x71, 0xec, 0x7b, 0x98, 0x1b, 0xd1, 0x07, 0x30, 0xeb, 0x61, 0x1c, 0xa9, 0x1a,
	0xd5, 0xa7, 0xbf, 0xb0, 0xfb, 0x18, 0x1f, 0xc8, 0xd7, 0x55, 0xda, 0xa1, 0x3b, 0x30, 0x83, 0x8f,
	0x23, 0xd5, 0x94, 0x9b, 0xd3, 0xcd, 0x5b, 0xcf, 0x63, 0x6b, 0x61, 0x65, 0xb8, 0x70, 0x2e, 0xd7,
	0x37, 0xd2, 0x61, 0x91, 0xf8, 0x76, 0xc0, 0xa8, 0xcf, 0x55, 0xb4, 0xfd, 0xb5, 0xd8, 0xeb, 0x46,
	0x24, 0x4c, 0xdd, 0x7e, 0xfd, 0x35, 0x7a, 0x03, 0x8a, 0x0c, 0x77, 0x79, 0xa7, 0x7d, 0x44, 0x4e,
	0x54, 0x1a, 0x17, 0xa5, 0xe0, 0x11, 0x39, 0x31, 0xbe, 0x84, 0x4a, 0x5e, 0x28, 0x22, 0x99, 0x21,
	0x71, 0x44, 0x59, 0x63, 0x28, 0xb5, 0x42, 0x06, 0x2c, 0x47, 0xc4, 0x0a, 0x09, 0x17, 0xde, 0xda,
	0xd4, 0x56, 0x68, 0x4b, 0xb1, 0xf0, 0x11, 0x39, 0xd9, 0xb3, 0x51, 0x1d, 0xd6, 0x94, 0x0e, 0xb6,
	0x2c, 0x12, 0x45, 0x29, 0xe0, 0x52, 0xbc, 0xd1, 0x92, 0x72, 0x81, 0x5f, 0x92, 0xef, 0xfa, 0xb3,
	0xb8, 0x67, 0xc4, 0xc3, 0xf4, 0x77, 0x41, 0xbe, 0xe1, 0x4a, 0x92, 0xdf, 0xc4, 0x1d, 0x28, 0xab,
	0x2e, 0x6b, 0x53, 0xff, 0x05, 0x0b, 0x3d, 0x39, 0xf5, 0xa9, 0x72, 0xbd, 0x3f, 0xe6, 0x48, 0x65,
	0x5c, 0x36, 0xd4, 0x62, 0x6f, 0x60, 0x6e, 0xa2, 0xde, 0x88, 0x4c, 0xff, 0x4b, 0x03, 0x34, 0xaa,
	0x8a, 0xde, 0x84, 0x25, 0x87, 0xf2, 0x76, 0xd2, 0xf9, 0x71, 0x8a, 0xc0, 0xa1, 0x09, 0x06, 0xba,
	0x0c, 0x62, 0xd5, 0xb6, 0x98, 0xe7, 0x51, 0x9e, 0x34, 0xb5, 0x43, 0xf9, 0x8e, 0x14, 0xa0, 0x6b,
	0xb0, 0x22, 0xb6, 0x79, 0x48, 0x48, 0x5b, 0xbc, 0x47, 0x44, 0xa5, 0xe7, 0xac, 0x43, 0xf9, 0xd3,
	0x90, 0x90, 0x03, 0x21, 0x13, 0x4e, 0x0e, 0xbb, 0xd4, 0xb5, 0xdb, 0xb6, 0xd0, 0x88, 0x7b, 0xbd,
	0x28, 0x25, 0x0f, 0xd4, 0xb6, 0xc3, 0xfa, 0x31, 0xcc, 0x29, 0x0c, 0x96, 0x84, 0xa0, 0xc3, 0xa2,
	0xc5, 0xbc, 0x80, 0x8a, 0xcb, 0x66, 0x3e, 0xae, 0x7a, 0xb2, 0x16, 0x7b, 0x81, 0x8b, 0xb9, 0x20,
	0x24, 0x67, 0x98, 0xa2, 0xd9, 0x5f, 0x6f, 0xff, 0x59, 0x84, 0x05, 0xd5, 0x0c, 0xa8, 0x0b, 0x30,
	0x98, 0x8d, 0x91, 0x91, 0x9b, 0xd9, 0xcc, 0x84, 0xad, 0x5f, 0x9b, 0xa2, 0x23, 0xb3, 0x6f, 0x5c,
	0xfe, 0xfa, 0xd7, 0xdf, 0xbf, 0x2f, 0x5c, 0x30, 0x90, 0x1c, 0xf3, 0x7b, 0x37, 0x9b, 0x1d, 0xa1,
	0x70, 0x2c, 0x14, 0x6e, 0x6b, 0x75, 0x74, 0x02, 0x4b, 0xa9, 0xa9, 0x19, 0x5d, 0x1d, 0x57, 0xd1,
	0xd4, 0x1c, 0xae, 0x5f, 0x9f, 0xa6, 0x14, 0x23, 0x5f, 0x91, 0xc8, 0x55, 0xa3, 0x9c, 0x20, 0x3b,
	0x84, 0x07, 0xcc, 0xb6, 0x84, 0x86, 0x80, 0xfe, 0x02, 0x96, 0x33, 0xe7, 0x01, 0x5d, 0x3f, 0xc5,
	0xe9, 0x8f, 0x1c, 0xfd, 0xed, 0xe9, 0x6a, 0x71, 0x00, 0xba, 0x0c, 0xa0, 0xa2, 0x97, 0x92, 0x00,
	0x94, 0x9d, 0x00, 0x67, 0x00, 0x83, 0xa1, 0x6c, 0x4c, 0xba, 0x33, 0x53, 0xf0, 0x98, 0x74, 0x0f,
	0xcd, 0xc0, 0xc6, 0x05, 0x89, 0xb9, 0x86, 0x86, 0x31, 0xd1, 0xe7, 0xb0, 0x9c, 0x19, 0x2c, 0xc7,
	0xb0, 0x1d, 0x1e, 0x52, 0xc7, 0xb0, 0x1d, 0x9d, 0x51, 0x13, 0xe4, 0xfa, 0x08, 0xf2, 0x2b, 0x4d,
	0xfe, 0x27, 0x95, 0x1a, 0x40, 0xd1, 0xfa, 0x14, 0x2e, 0x6a, 0x74, 0xd5, 0x37, 0x4e, 0xa1, 0x17,
	0xa3, 0x5f, 0x92, 0xe8, 0xe7, 0x51, 0x65, 0x08, 0xbd, 0xe9, 0x0a, 0xbc, 0x57, 0x1a, 0x94, 0x86,
	0x86, 0x1e, 0x94, 0x4f, 0x6c, 0x74, 0xa0, 0xd3, 0x37, 0x4f, 0xa3, 0x18, 0x47, 0x71, 0x51, 0x46,
	0x51, 0x36, 0x56, 0x92, 0x28, 0xe2, 0x87, 0x5c, 0x14, 0xfc, 0x2b, 0x0d, 0x56, 0x87, 0x67, 0x10,
	0x94, 0xcf, 0x2f, 0x67, 0xb6, 0xd2, 0xeb, 0xa7, 0xd2, 0xcc, 0x54, 0x42, 0x3f, 0x9b, 0x3a, 0x72,
	0x5e, 0xdc, 0xf1, 0xa5, 0xa1, 0xc9, 0x01, 0x4d, 0x2a, 0x6f, 0x26, 0x80, 0xcd, 0xd3, 0x28, 0xc6,
	0xf8, 0x15, 0x89, 0xbf, 0x52, 0xcf, 0xe0, 0xa3, 0x97, 0x70, 0x6e, 0x70, 0x33, 0xa7, 0x6f, 0x58,
	0x63, 0xca, 0x2d, 0x3e, 0xb1, 0xf9, 0xd3, 0x37, 0xfd, 0x68, 0xf3, 0xab, 0x1b, 0xf3, 0xfe, 0x1f,
	0xda, 0x77, 0xad, 0xdf, 0x34, 0xf4, 0x29, 0x94, 0x55, 0xe3, 0xd4, 0xf6, 0x63, 0x37, 0xb5, 0xd6,
	0x93, 0x3d, 0xa3, 0x05, 0xa5, 0x7d, 0x6a, 0x75, 0x30, 0x71, 0x6b, 0xcf, 0x88, 0x4f, 0x5e, 0x52,
	0x8c, 0xf4, 0x0e, 0xe7, 0x41, 0x74, 0xbb, 0xd9, 0x74, 0x28, 0xef, 0x74, 0x0f, 0x1b, 0x16, 0xf3,
	0x9a, 0xbd, 0x78, 0x4f, 0x47, 0x9e, 0xfa, 0xba, 0xe7, 0x78, 0x98, 0xba, 0x62, 0x6f, 0x7b, 0xbe,
	0x77, 0xa3, 0x71, 0xb3, 0x71, 0xa3, 0x5e, 0xd0, 0x0a, 0xdb, 0xab, 0x38, 0x08, 0x5c, 0x6a, 0x49,
	0x72, 0xcd, 0xcf, 0x22, 0xe6, 0xdf, 0x1e, 0x91, 0x84, 0x9f, 0xc0, 0x95, 0x7d, 0x16, 0x92, 0x1a,
	0x3e, 0x64, 0x5d, 0x5e, 0xcb, 0x09, 0x0a, 0xdd, 0xca, 0x89, 0x20, 0xc2, 0x5e, 0xd4, 0xf5, 0x9d,
	0x2d, 0xcb, 0xb7, 0x78, 0xd2, 0xe0, 0x5b, 0x2a, 0x21, 0x5b, 0x38, 0xa0, 0x87, 0xf3, 0xf2, 0xc7,
	0x90, 0x5b, 0xff, 0x04, 0x00, 0x00, 0xff, 0xff, 0x70, 0x61, 0xdc, 0x93, 0x7a, 0x11, 0x00, 0x00,
}
